# Report

- **`Race condition and fixed with mutex`**
    
    **Race condition**
    
    <aside>
    ğŸ“ Race condition (yarÄ±ÅŸ koÅŸulu) problemi, birden fazla iÅŸlemci veya iÅŸ parÃ§acÄ±ÄŸÄ± tarafÄ±ndan paylaÅŸÄ±lan ortak bir kaynaÄŸÄ±n (Ã¶rneÄŸin bellek, dosya vb.) eÅŸ zamanlÄ± olarak kullanÄ±lmasÄ± durumunda ortaya Ã§Ä±kan bir programlama hatasÄ±dÄ±r. Bu durumda, iÅŸlemler birbirleriyle karÄ±ÅŸarak beklenmeyen sonuÃ§lar Ã¼retebilir.
    
    C dilinde bir Ã¶rnek vermek gerekirse, iki farklÄ± iÅŸ parÃ§acÄ±ÄŸÄ± tarafÄ±ndan paylaÅŸÄ±lan bir deÄŸiÅŸkenin aynÄ± anda okunmasÄ± ve yazÄ±lmasÄ± durumunda bir race condition oluÅŸabilir. Ã–rneÄŸin, aÅŸaÄŸÄ±daki kodda iki iÅŸ parÃ§acÄ±ÄŸÄ± aynÄ± anda "count" deÄŸiÅŸkenini artÄ±rabilir:
    
    </aside>
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    
    int count = 0;
    
    void *thread_func(void *arg){
        int i;
        for(i = 0; i < 10; i++){
            count++;
            printf("%d ", count);
        }
        printf("\n\n");
        return NULL;
    }
    
    int main(){
        pthread_t thread1, thread2;
    
        pthread_create(&thread1, NULL, thread_func, NULL);
        pthread_create(&thread2, NULL, thread_func, NULL);
    
        pthread_join(thread1, NULL);
        pthread_join(thread2, NULL);
    
        printf("\n\ncount = %d\n", count);
        return 0;
    }
    ```
    
    <aside>
    ğŸ“ Bu kodda, iki iÅŸ parÃ§acÄ±ÄŸÄ± "count" deÄŸiÅŸkenini aynÄ± anda artÄ±rdÄ±ÄŸÄ± iÃ§in sonuÃ§ beklenmedik olabilir. Ã–rneÄŸin, her iki iÅŸ parÃ§acÄ±ÄŸÄ± da "count" deÄŸiÅŸkenini okuyup 1 artÄ±rdÄ±ÄŸÄ±nda, sonuÃ§ta "count" deÄŸiÅŸkeninin beklenenden daha az bir deÄŸere sahip olmasÄ± mÃ¼mkÃ¼ndÃ¼r.
    
    Bu nedenle, birden fazla iÅŸlemci veya iÅŸ parÃ§acÄ±ÄŸÄ± tarafÄ±ndan paylaÅŸÄ±lan ortak kaynaklarÄ±n eÅŸ zamanlÄ± eriÅŸimine dikkat edilmelidir. Bu tÃ¼r durumlarda, senkronizasyon teknikleri (Ã¶rneÄŸin, kilitleme) kullanÄ±larak race condition problemleri Ã¶nlenebilir.
    
    </aside>
    
    **Race condition fixed with mutex**
    
    <aside>
    ğŸ“ YukarÄ±daki kodda, race condition problemi Ã§Ã¶zÃ¼lebilir bir ÅŸekilde gÃ¼ncellenebilir. Bunun iÃ§in bir senkronizasyon mekanizmasÄ± kullanarak, aynÄ± anda iki iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n "count" deÄŸiÅŸkenine eriÅŸmesini engellemek gerekiyor.
    
    Bunun iÃ§in C dilinde mutex (mutual exclusion) kullanÄ±labilir. Mutex, sadece bir iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n aynÄ± anda bir kaynaÄŸa eriÅŸmesine izin veren bir senkronizasyon mekanizmasÄ±dÄ±r. AÅŸaÄŸÄ±daki ÅŸekilde, mutex kullanarak "count" deÄŸiÅŸkenine aynÄ± anda sadece bir iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n eriÅŸmesini saÄŸlayacak ÅŸekilde gÃ¼ncellenmiÅŸ kodu gÃ¶rebilirsiniz:
    
    </aside>
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    
    int count = 0;
    pthread_mutex_t mutex;
    
    void *thread_func(void *arg){
        int i;
        for(i = 0; i< 10; i++){
            pthread_mutex_lock(&mutex);
            count++;
            printf("%d ", count);
            pthread_mutex_unlock(&mutex);
        }
        printf("\n\n");
        return NULL;
    }
    
    int main(){
        pthread_t thread1, thread2;
    
        pthread_mutex_init(&mutex, NULL);
    
        pthread_create(&thread1, NULL, thread_func, NULL);
        pthread_create(&thread2, NULL, thread_func, NULL);
    
        pthread_join(thread1, NULL);
        pthread_join(thread2, NULL);
    
        pthread_mutex_destroy(&mutex);
    
        printf("\n\ncount = %d\n", count);
        return 0;
    }
    ```
    
    <aside>
    ğŸ“ Bu gÃ¼ncellenmiÅŸ kodda, "count" deÄŸiÅŸkenine eriÅŸimi senkronize etmek iÃ§in bir mutex kullanÄ±lmaktadÄ±r. Ä°ÅŸ parÃ§acÄ±klarÄ± "count" deÄŸiÅŸkenine eriÅŸmeden Ã¶nce mutex kilidini alÄ±r ve iÅŸlemlerini tamamladÄ±ktan sonra mutex kilidini serbest bÄ±rakÄ±rlar. Bu ÅŸekilde, aynÄ± anda sadece bir iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n "count" deÄŸiÅŸkenine eriÅŸmesi saÄŸlanÄ±r.
    
    AyrÄ±ca, kodun baÅŸÄ±nda **`pthread_mutex_t`** tipinde bir mutex tanÄ±mlanmÄ±ÅŸ ve **`pthread_mutex_init`** fonksiyonu kullanÄ±larak mutex baÅŸlatÄ±lmÄ±ÅŸtÄ±r. Mutex kullanÄ±mÄ± bittiÄŸinde **`pthread_mutex_destroy`** fonksiyonu ile silinmelidir.
    
    </aside>